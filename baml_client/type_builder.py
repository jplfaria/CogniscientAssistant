###############################################################################
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml-py
#
###############################################################################

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code.
#
# ruff: noqa: E501,F401
# flake8: noqa: E501,F401
# pylint: disable=unused-import,line-too-long
# fmt: off
import typing
from baml_py.baml_py import FieldType, EnumValueBuilder, EnumBuilder, ClassBuilder
from baml_py.type_builder import TypeBuilder as _TypeBuilder, ClassPropertyBuilder, ClassPropertyViewer, EnumValueViewer
from .globals import DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME


class TypeBuilder(_TypeBuilder):
    def __init__(self):
        super().__init__(classes=set(
          ["AgentRequest","AgentResponse","AssumptionDecomposition","Citation","ComparisonResult","ErrorInfo","ExperimentalProtocol","FailurePoint","Hypothesis","HypothesisSummary","ParsedResearchGoal","RequestContent","ResearchPatterns","ResponseData","Review","ReviewScores","SafetyCheck","SimilarityScore","SimulationResults","Task",]
        ), enums=set(
          ["AgentType","ConfidenceLevel","Criticality","HypothesisCategory","RequestType","ResponseStatus","ReviewDecision","ReviewType","SafetyCategory","SafetyLevel","TaskState","TaskType","Validity",]
        ), runtime=DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME)


    @property
    def AgentRequest(self) -> "AgentRequestAst":
        return AgentRequestAst(self)

    @property
    def AgentResponse(self) -> "AgentResponseAst":
        return AgentResponseAst(self)

    @property
    def AssumptionDecomposition(self) -> "AssumptionDecompositionAst":
        return AssumptionDecompositionAst(self)

    @property
    def Citation(self) -> "CitationAst":
        return CitationAst(self)

    @property
    def ComparisonResult(self) -> "ComparisonResultAst":
        return ComparisonResultAst(self)

    @property
    def ErrorInfo(self) -> "ErrorInfoAst":
        return ErrorInfoAst(self)

    @property
    def ExperimentalProtocol(self) -> "ExperimentalProtocolAst":
        return ExperimentalProtocolAst(self)

    @property
    def FailurePoint(self) -> "FailurePointAst":
        return FailurePointAst(self)

    @property
    def Hypothesis(self) -> "HypothesisAst":
        return HypothesisAst(self)

    @property
    def HypothesisSummary(self) -> "HypothesisSummaryAst":
        return HypothesisSummaryAst(self)

    @property
    def ParsedResearchGoal(self) -> "ParsedResearchGoalAst":
        return ParsedResearchGoalAst(self)

    @property
    def RequestContent(self) -> "RequestContentAst":
        return RequestContentAst(self)

    @property
    def ResearchPatterns(self) -> "ResearchPatternsAst":
        return ResearchPatternsAst(self)

    @property
    def ResponseData(self) -> "ResponseDataAst":
        return ResponseDataAst(self)

    @property
    def Review(self) -> "ReviewAst":
        return ReviewAst(self)

    @property
    def ReviewScores(self) -> "ReviewScoresAst":
        return ReviewScoresAst(self)

    @property
    def SafetyCheck(self) -> "SafetyCheckAst":
        return SafetyCheckAst(self)

    @property
    def SimilarityScore(self) -> "SimilarityScoreAst":
        return SimilarityScoreAst(self)

    @property
    def SimulationResults(self) -> "SimulationResultsAst":
        return SimulationResultsAst(self)

    @property
    def Task(self) -> "TaskAst":
        return TaskAst(self)





class AgentRequestAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("AgentRequest")
        self._properties: typing.Set[str] = set([ "request_id",  "agent_type",  "request_type",  "content", ])
        self._props = AgentRequestProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "AgentRequestProperties":
        return self._props


class AgentRequestViewer(AgentRequestAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class AgentRequestProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def request_id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("request_id"))

    @property
    def agent_type(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("agent_type"))

    @property
    def request_type(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("request_type"))

    @property
    def content(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("content"))

    

class AgentResponseAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("AgentResponse")
        self._properties: typing.Set[str] = set([ "request_id",  "status",  "response",  "error", ])
        self._props = AgentResponseProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "AgentResponseProperties":
        return self._props


class AgentResponseViewer(AgentResponseAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class AgentResponseProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def request_id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("request_id"))

    @property
    def status(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("status"))

    @property
    def response(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("response"))

    @property
    def error(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("error"))

    

class AssumptionDecompositionAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("AssumptionDecomposition")
        self._properties: typing.Set[str] = set([ "assumption",  "validity",  "evidence",  "criticality", ])
        self._props = AssumptionDecompositionProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "AssumptionDecompositionProperties":
        return self._props


class AssumptionDecompositionViewer(AssumptionDecompositionAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class AssumptionDecompositionProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def assumption(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("assumption"))

    @property
    def validity(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("validity"))

    @property
    def evidence(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("evidence"))

    @property
    def criticality(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("criticality"))

    

class CitationAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Citation")
        self._properties: typing.Set[str] = set([ "authors",  "title",  "journal",  "year",  "doi",  "url", ])
        self._props = CitationProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "CitationProperties":
        return self._props


class CitationViewer(CitationAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class CitationProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def authors(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("authors"))

    @property
    def title(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("title"))

    @property
    def journal(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("journal"))

    @property
    def year(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("year"))

    @property
    def doi(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("doi"))

    @property
    def url(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("url"))

    

class ComparisonResultAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ComparisonResult")
        self._properties: typing.Set[str] = set([ "winner_id",  "confidence",  "reasoning",  "strengths_h1",  "strengths_h2",  "decisive_factors", ])
        self._props = ComparisonResultProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ComparisonResultProperties":
        return self._props


class ComparisonResultViewer(ComparisonResultAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ComparisonResultProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def winner_id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("winner_id"))

    @property
    def confidence(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("confidence"))

    @property
    def reasoning(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("reasoning"))

    @property
    def strengths_h1(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("strengths_h1"))

    @property
    def strengths_h2(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("strengths_h2"))

    @property
    def decisive_factors(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("decisive_factors"))

    

class ErrorInfoAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ErrorInfo")
        self._properties: typing.Set[str] = set([ "code",  "message",  "recoverable", ])
        self._props = ErrorInfoProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ErrorInfoProperties":
        return self._props


class ErrorInfoViewer(ErrorInfoAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ErrorInfoProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def code(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("code"))

    @property
    def message(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("message"))

    @property
    def recoverable(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("recoverable"))

    

class ExperimentalProtocolAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ExperimentalProtocol")
        self._properties: typing.Set[str] = set([ "objective",  "methodology",  "required_resources",  "timeline",  "success_metrics",  "potential_challenges",  "safety_considerations", ])
        self._props = ExperimentalProtocolProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ExperimentalProtocolProperties":
        return self._props


class ExperimentalProtocolViewer(ExperimentalProtocolAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ExperimentalProtocolProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def objective(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("objective"))

    @property
    def methodology(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("methodology"))

    @property
    def required_resources(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("required_resources"))

    @property
    def timeline(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("timeline"))

    @property
    def success_metrics(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("success_metrics"))

    @property
    def potential_challenges(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("potential_challenges"))

    @property
    def safety_considerations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("safety_considerations"))

    

class FailurePointAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("FailurePoint")
        self._properties: typing.Set[str] = set([ "step",  "probability",  "impact", ])
        self._props = FailurePointProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "FailurePointProperties":
        return self._props


class FailurePointViewer(FailurePointAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class FailurePointProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def step(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("step"))

    @property
    def probability(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("probability"))

    @property
    def impact(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("impact"))

    

class HypothesisAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Hypothesis")
        self._properties: typing.Set[str] = set([ "id",  "summary",  "category",  "full_description",  "novelty_claim",  "assumptions",  "experimental_protocol",  "supporting_evidence",  "confidence_score",  "generation_method",  "created_at",  "elo_rating",  "review_count",  "evolution_count", ])
        self._props = HypothesisProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "HypothesisProperties":
        return self._props


class HypothesisViewer(HypothesisAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class HypothesisProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("id"))

    @property
    def summary(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("summary"))

    @property
    def category(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("category"))

    @property
    def full_description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("full_description"))

    @property
    def novelty_claim(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("novelty_claim"))

    @property
    def assumptions(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("assumptions"))

    @property
    def experimental_protocol(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("experimental_protocol"))

    @property
    def supporting_evidence(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("supporting_evidence"))

    @property
    def confidence_score(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("confidence_score"))

    @property
    def generation_method(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("generation_method"))

    @property
    def created_at(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("created_at"))

    @property
    def elo_rating(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("elo_rating"))

    @property
    def review_count(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("review_count"))

    @property
    def evolution_count(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("evolution_count"))

    

class HypothesisSummaryAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("HypothesisSummary")
        self._properties: typing.Set[str] = set([ "core_idea",  "scientific_impact",  "feasibility_assessment",  "next_steps", ])
        self._props = HypothesisSummaryProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "HypothesisSummaryProperties":
        return self._props


class HypothesisSummaryViewer(HypothesisSummaryAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class HypothesisSummaryProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def core_idea(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("core_idea"))

    @property
    def scientific_impact(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("scientific_impact"))

    @property
    def feasibility_assessment(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("feasibility_assessment"))

    @property
    def next_steps(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("next_steps"))

    

class ParsedResearchGoalAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ParsedResearchGoal")
        self._properties: typing.Set[str] = set([ "primary_objective",  "sub_objectives",  "implied_constraints",  "suggested_categories",  "key_terms",  "success_criteria", ])
        self._props = ParsedResearchGoalProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ParsedResearchGoalProperties":
        return self._props


class ParsedResearchGoalViewer(ParsedResearchGoalAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ParsedResearchGoalProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def primary_objective(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("primary_objective"))

    @property
    def sub_objectives(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("sub_objectives"))

    @property
    def implied_constraints(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("implied_constraints"))

    @property
    def suggested_categories(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("suggested_categories"))

    @property
    def key_terms(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("key_terms"))

    @property
    def success_criteria(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("success_criteria"))

    

class RequestContentAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("RequestContent")
        self._properties: typing.Set[str] = set([ "prompt",  "context",  "parameters", ])
        self._props = RequestContentProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "RequestContentProperties":
        return self._props


class RequestContentViewer(RequestContentAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class RequestContentProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def prompt(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("prompt"))

    @property
    def context(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("context"))

    @property
    def parameters(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("parameters"))

    

class ResearchPatternsAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ResearchPatterns")
        self._properties: typing.Set[str] = set([ "identified_patterns",  "common_strengths",  "common_weaknesses",  "emerging_themes",  "recommendations",  "synthesis_summary", ])
        self._props = ResearchPatternsProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ResearchPatternsProperties":
        return self._props


class ResearchPatternsViewer(ResearchPatternsAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ResearchPatternsProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def identified_patterns(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("identified_patterns"))

    @property
    def common_strengths(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("common_strengths"))

    @property
    def common_weaknesses(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("common_weaknesses"))

    @property
    def emerging_themes(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("emerging_themes"))

    @property
    def recommendations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("recommendations"))

    @property
    def synthesis_summary(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("synthesis_summary"))

    

class ResponseDataAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ResponseData")
        self._properties: typing.Set[str] = set([ "content",  "metadata", ])
        self._props = ResponseDataProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ResponseDataProperties":
        return self._props


class ResponseDataViewer(ResponseDataAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ResponseDataProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def content(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("content"))

    @property
    def metadata(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("metadata"))

    

class ReviewAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Review")
        self._properties: typing.Set[str] = set([ "id",  "hypothesis_id",  "reviewer_agent_id",  "review_type",  "decision",  "scores",  "narrative_feedback",  "key_strengths",  "key_weaknesses",  "improvement_suggestions",  "confidence_level",  "assumption_decomposition",  "simulation_results",  "literature_citations",  "created_at",  "time_spent_seconds", ])
        self._props = ReviewProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ReviewProperties":
        return self._props


class ReviewViewer(ReviewAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ReviewProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("id"))

    @property
    def hypothesis_id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("hypothesis_id"))

    @property
    def reviewer_agent_id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("reviewer_agent_id"))

    @property
    def review_type(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("review_type"))

    @property
    def decision(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("decision"))

    @property
    def scores(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("scores"))

    @property
    def narrative_feedback(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("narrative_feedback"))

    @property
    def key_strengths(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("key_strengths"))

    @property
    def key_weaknesses(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("key_weaknesses"))

    @property
    def improvement_suggestions(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("improvement_suggestions"))

    @property
    def confidence_level(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("confidence_level"))

    @property
    def assumption_decomposition(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("assumption_decomposition"))

    @property
    def simulation_results(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("simulation_results"))

    @property
    def literature_citations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("literature_citations"))

    @property
    def created_at(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("created_at"))

    @property
    def time_spent_seconds(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("time_spent_seconds"))

    

class ReviewScoresAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ReviewScores")
        self._properties: typing.Set[str] = set([ "correctness",  "quality",  "novelty",  "safety",  "feasibility", ])
        self._props = ReviewScoresProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ReviewScoresProperties":
        return self._props


class ReviewScoresViewer(ReviewScoresAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ReviewScoresProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def correctness(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("correctness"))

    @property
    def quality(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("quality"))

    @property
    def novelty(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("novelty"))

    @property
    def safety(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("safety"))

    @property
    def feasibility(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("feasibility"))

    

class SafetyCheckAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SafetyCheck")
        self._properties: typing.Set[str] = set([ "id",  "target_type",  "target_id",  "safety_level",  "passed",  "checks_performed",  "violations",  "recommendations",  "category",  "timestamp",  "metadata", ])
        self._props = SafetyCheckProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SafetyCheckProperties":
        return self._props


class SafetyCheckViewer(SafetyCheckAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class SafetyCheckProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("id"))

    @property
    def target_type(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("target_type"))

    @property
    def target_id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("target_id"))

    @property
    def safety_level(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("safety_level"))

    @property
    def passed(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("passed"))

    @property
    def checks_performed(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("checks_performed"))

    @property
    def violations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("violations"))

    @property
    def recommendations(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("recommendations"))

    @property
    def category(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("category"))

    @property
    def timestamp(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("timestamp"))

    @property
    def metadata(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("metadata"))

    

class SimilarityScoreAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SimilarityScore")
        self._properties: typing.Set[str] = set([ "overall_similarity",  "aspect_scores",  "shared_concepts",  "key_differences", ])
        self._props = SimilarityScoreProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SimilarityScoreProperties":
        return self._props


class SimilarityScoreViewer(SimilarityScoreAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class SimilarityScoreProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def overall_similarity(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("overall_similarity"))

    @property
    def aspect_scores(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("aspect_scores"))

    @property
    def shared_concepts(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("shared_concepts"))

    @property
    def key_differences(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("key_differences"))

    

class SimulationResultsAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SimulationResults")
        self._properties: typing.Set[str] = set([ "mechanism_steps",  "failure_points",  "predicted_outcomes", ])
        self._props = SimulationResultsProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SimulationResultsProperties":
        return self._props


class SimulationResultsViewer(SimulationResultsAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class SimulationResultsProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def mechanism_steps(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("mechanism_steps"))

    @property
    def failure_points(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("failure_points"))

    @property
    def predicted_outcomes(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("predicted_outcomes"))

    

class TaskAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Task")
        self._properties: typing.Set[str] = set([ "id",  "task_type",  "priority",  "state",  "payload",  "assigned_to",  "result",  "error",  "created_at",  "assigned_at",  "completed_at", ])
        self._props = TaskProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "TaskProperties":
        return self._props


class TaskViewer(TaskAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class TaskProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def id(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("id"))

    @property
    def task_type(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("task_type"))

    @property
    def priority(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("priority"))

    @property
    def state(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("state"))

    @property
    def payload(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("payload"))

    @property
    def assigned_to(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("assigned_to"))

    @property
    def result(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("result"))

    @property
    def error(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("error"))

    @property
    def created_at(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("created_at"))

    @property
    def assigned_at(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("assigned_at"))

    @property
    def completed_at(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("completed_at"))

    



class AgentTypeAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("AgentType")
        self._values: typing.Set[str] = set([ "Generation",  "Reflection",  "Ranking",  "Evolution",  "Proximity",  "MetaReview",  "Supervisor", ])
        self._vals = AgentTypeValues(self._bldr, self._values)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "AgentTypeValues":
        return self._vals


class AgentTypeViewer(AgentTypeAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    def list_values(self) -> typing.List[typing.Tuple[str, EnumValueViewer]]:
        return [(name, EnumValueViewer(self._bldr.value(name))) for name in self._values]


class AgentTypeValues:
    def __init__(self, enum_bldr: EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values

    

    @property
    def Generation(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Generation"))
    

    @property
    def Reflection(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Reflection"))
    

    @property
    def Ranking(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Ranking"))
    

    @property
    def Evolution(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Evolution"))
    

    @property
    def Proximity(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Proximity"))
    

    @property
    def MetaReview(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("MetaReview"))
    

    @property
    def Supervisor(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Supervisor"))
    

    

class ConfidenceLevelAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("ConfidenceLevel")
        self._values: typing.Set[str] = set([ "High",  "Medium",  "Low", ])
        self._vals = ConfidenceLevelValues(self._bldr, self._values)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "ConfidenceLevelValues":
        return self._vals


class ConfidenceLevelViewer(ConfidenceLevelAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    def list_values(self) -> typing.List[typing.Tuple[str, EnumValueViewer]]:
        return [(name, EnumValueViewer(self._bldr.value(name))) for name in self._values]


class ConfidenceLevelValues:
    def __init__(self, enum_bldr: EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values

    

    @property
    def High(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("High"))
    

    @property
    def Medium(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Medium"))
    

    @property
    def Low(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Low"))
    

    

class CriticalityAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("Criticality")
        self._values: typing.Set[str] = set([ "Fundamental",  "Peripheral", ])
        self._vals = CriticalityValues(self._bldr, self._values)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "CriticalityValues":
        return self._vals


class CriticalityViewer(CriticalityAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    def list_values(self) -> typing.List[typing.Tuple[str, EnumValueViewer]]:
        return [(name, EnumValueViewer(self._bldr.value(name))) for name in self._values]


class CriticalityValues:
    def __init__(self, enum_bldr: EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values

    

    @property
    def Fundamental(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Fundamental"))
    

    @property
    def Peripheral(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Peripheral"))
    

    

class HypothesisCategoryAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("HypothesisCategory")
        self._values: typing.Set[str] = set([ "Mechanistic",  "Therapeutic",  "Diagnostic",  "Biomarker",  "Methodology",  "Other", ])
        self._vals = HypothesisCategoryValues(self._bldr, self._values)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "HypothesisCategoryValues":
        return self._vals


class HypothesisCategoryViewer(HypothesisCategoryAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    def list_values(self) -> typing.List[typing.Tuple[str, EnumValueViewer]]:
        return [(name, EnumValueViewer(self._bldr.value(name))) for name in self._values]


class HypothesisCategoryValues:
    def __init__(self, enum_bldr: EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values

    

    @property
    def Mechanistic(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Mechanistic"))
    

    @property
    def Therapeutic(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Therapeutic"))
    

    @property
    def Diagnostic(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Diagnostic"))
    

    @property
    def Biomarker(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Biomarker"))
    

    @property
    def Methodology(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Methodology"))
    

    @property
    def Other(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Other"))
    

    

class RequestTypeAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("RequestType")
        self._values: typing.Set[str] = set([ "Generate",  "Analyze",  "Evaluate",  "Compare", ])
        self._vals = RequestTypeValues(self._bldr, self._values)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "RequestTypeValues":
        return self._vals


class RequestTypeViewer(RequestTypeAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    def list_values(self) -> typing.List[typing.Tuple[str, EnumValueViewer]]:
        return [(name, EnumValueViewer(self._bldr.value(name))) for name in self._values]


class RequestTypeValues:
    def __init__(self, enum_bldr: EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values

    

    @property
    def Generate(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Generate"))
    

    @property
    def Analyze(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Analyze"))
    

    @property
    def Evaluate(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Evaluate"))
    

    @property
    def Compare(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Compare"))
    

    

class ResponseStatusAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("ResponseStatus")
        self._values: typing.Set[str] = set([ "Success",  "Error",  "Partial", ])
        self._vals = ResponseStatusValues(self._bldr, self._values)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "ResponseStatusValues":
        return self._vals


class ResponseStatusViewer(ResponseStatusAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    def list_values(self) -> typing.List[typing.Tuple[str, EnumValueViewer]]:
        return [(name, EnumValueViewer(self._bldr.value(name))) for name in self._values]


class ResponseStatusValues:
    def __init__(self, enum_bldr: EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values

    

    @property
    def Success(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Success"))
    

    @property
    def Error(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Error"))
    

    @property
    def Partial(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Partial"))
    

    

class ReviewDecisionAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("ReviewDecision")
        self._values: typing.Set[str] = set([ "Accept",  "Reject",  "Revise", ])
        self._vals = ReviewDecisionValues(self._bldr, self._values)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "ReviewDecisionValues":
        return self._vals


class ReviewDecisionViewer(ReviewDecisionAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    def list_values(self) -> typing.List[typing.Tuple[str, EnumValueViewer]]:
        return [(name, EnumValueViewer(self._bldr.value(name))) for name in self._values]


class ReviewDecisionValues:
    def __init__(self, enum_bldr: EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values

    

    @property
    def Accept(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Accept"))
    

    @property
    def Reject(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Reject"))
    

    @property
    def Revise(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Revise"))
    

    

class ReviewTypeAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("ReviewType")
        self._values: typing.Set[str] = set([ "Initial",  "Full",  "DeepVerification",  "Observation",  "Simulation",  "Tournament", ])
        self._vals = ReviewTypeValues(self._bldr, self._values)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "ReviewTypeValues":
        return self._vals


class ReviewTypeViewer(ReviewTypeAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    def list_values(self) -> typing.List[typing.Tuple[str, EnumValueViewer]]:
        return [(name, EnumValueViewer(self._bldr.value(name))) for name in self._values]


class ReviewTypeValues:
    def __init__(self, enum_bldr: EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values

    

    @property
    def Initial(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Initial"))
    

    @property
    def Full(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Full"))
    

    @property
    def DeepVerification(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("DeepVerification"))
    

    @property
    def Observation(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Observation"))
    

    @property
    def Simulation(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Simulation"))
    

    @property
    def Tournament(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Tournament"))
    

    

class SafetyCategoryAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("SafetyCategory")
        self._values: typing.Set[str] = set([ "ContentSafety",  "GoalViolation",  "EthicalConcern",  "ResourceMisuse", ])
        self._vals = SafetyCategoryValues(self._bldr, self._values)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "SafetyCategoryValues":
        return self._vals


class SafetyCategoryViewer(SafetyCategoryAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    def list_values(self) -> typing.List[typing.Tuple[str, EnumValueViewer]]:
        return [(name, EnumValueViewer(self._bldr.value(name))) for name in self._values]


class SafetyCategoryValues:
    def __init__(self, enum_bldr: EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values

    

    @property
    def ContentSafety(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("ContentSafety"))
    

    @property
    def GoalViolation(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("GoalViolation"))
    

    @property
    def EthicalConcern(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("EthicalConcern"))
    

    @property
    def ResourceMisuse(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("ResourceMisuse"))
    

    

class SafetyLevelAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("SafetyLevel")
        self._values: typing.Set[str] = set([ "Safe",  "Concerning",  "Blocked", ])
        self._vals = SafetyLevelValues(self._bldr, self._values)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "SafetyLevelValues":
        return self._vals


class SafetyLevelViewer(SafetyLevelAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    def list_values(self) -> typing.List[typing.Tuple[str, EnumValueViewer]]:
        return [(name, EnumValueViewer(self._bldr.value(name))) for name in self._values]


class SafetyLevelValues:
    def __init__(self, enum_bldr: EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values

    

    @property
    def Safe(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Safe"))
    

    @property
    def Concerning(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Concerning"))
    

    @property
    def Blocked(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Blocked"))
    

    

class TaskStateAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("TaskState")
        self._values: typing.Set[str] = set([ "Pending",  "Assigned",  "Executing",  "Completed",  "Failed", ])
        self._vals = TaskStateValues(self._bldr, self._values)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "TaskStateValues":
        return self._vals


class TaskStateViewer(TaskStateAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    def list_values(self) -> typing.List[typing.Tuple[str, EnumValueViewer]]:
        return [(name, EnumValueViewer(self._bldr.value(name))) for name in self._values]


class TaskStateValues:
    def __init__(self, enum_bldr: EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values

    

    @property
    def Pending(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Pending"))
    

    @property
    def Assigned(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Assigned"))
    

    @property
    def Executing(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Executing"))
    

    @property
    def Completed(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Completed"))
    

    @property
    def Failed(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Failed"))
    

    

class TaskTypeAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("TaskType")
        self._values: typing.Set[str] = set([ "GenerateHypothesis",  "ReflectOnHypothesis",  "RankHypotheses",  "EvolveHypothesis",  "FindSimilarHypotheses",  "MetaReview", ])
        self._vals = TaskTypeValues(self._bldr, self._values)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "TaskTypeValues":
        return self._vals


class TaskTypeViewer(TaskTypeAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    def list_values(self) -> typing.List[typing.Tuple[str, EnumValueViewer]]:
        return [(name, EnumValueViewer(self._bldr.value(name))) for name in self._values]


class TaskTypeValues:
    def __init__(self, enum_bldr: EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values

    

    @property
    def GenerateHypothesis(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("GenerateHypothesis"))
    

    @property
    def ReflectOnHypothesis(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("ReflectOnHypothesis"))
    

    @property
    def RankHypotheses(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("RankHypotheses"))
    

    @property
    def EvolveHypothesis(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("EvolveHypothesis"))
    

    @property
    def FindSimilarHypotheses(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("FindSimilarHypotheses"))
    

    @property
    def MetaReview(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("MetaReview"))
    

    

class ValidityAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.enum("Validity")
        self._values: typing.Set[str] = set([ "Valid",  "Questionable",  "Invalid", ])
        self._vals = ValidityValues(self._bldr, self._values)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def values(self) -> "ValidityValues":
        return self._vals


class ValidityViewer(ValidityAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    def list_values(self) -> typing.List[typing.Tuple[str, EnumValueViewer]]:
        return [(name, EnumValueViewer(self._bldr.value(name))) for name in self._values]


class ValidityValues:
    def __init__(self, enum_bldr: EnumBuilder, values: typing.Set[str]):
        self.__bldr = enum_bldr
        self.__values = values

    

    @property
    def Valid(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Valid"))
    

    @property
    def Questionable(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Questionable"))
    

    @property
    def Invalid(self) -> EnumValueViewer:
        return EnumValueViewer(self.__bldr.value("Invalid"))
    

    


__all__ = ["TypeBuilder"]