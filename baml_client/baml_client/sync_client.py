# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

import typing
import typing_extensions
import baml_py

from . import stream_types, types, type_builder
from .parser import LlmResponseParser, LlmStreamParser
from .runtime import DoNotUseDirectlyCallManager, BamlCallOptions
from .globals import DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME as __runtime__

class BamlSyncClient:
    __options: DoNotUseDirectlyCallManager
    __stream_client: "BamlStreamClient"
    __http_request: "BamlHttpRequestClient"
    __http_stream_request: "BamlHttpStreamRequestClient"
    __llm_response_parser: LlmResponseParser
    __llm_stream_parser: LlmStreamParser

    def __init__(self, options: DoNotUseDirectlyCallManager):
        self.__options = options
        self.__stream_client = BamlStreamClient(options)
        self.__http_request = BamlHttpRequestClient(options)
        self.__http_stream_request = BamlHttpStreamRequestClient(options)
        self.__llm_response_parser = LlmResponseParser(options)
        self.__llm_stream_parser = LlmStreamParser(options)

    def __getstate__(self):
        # Return state needed for pickling
        return {"options": self.__options}

    def __setstate__(self, state):
        # Restore state from pickling
        self.__options = state["options"]
        self.__stream_client = BamlStreamClient(self.__options)
        self.__http_request = BamlHttpRequestClient(self.__options)
        self.__http_stream_request = BamlHttpStreamRequestClient(self.__options)
        self.__llm_response_parser = LlmResponseParser(self.__options)
        self.__llm_stream_parser = LlmStreamParser(self.__options)

    def with_options(self,
        tb: typing.Optional[type_builder.TypeBuilder] = None,
        client_registry: typing.Optional[baml_py.baml_py.ClientRegistry] = None,
        collector: typing.Optional[typing.Union[baml_py.baml_py.Collector, typing.List[baml_py.baml_py.Collector]]] = None,
        env: typing.Optional[typing.Dict[str, typing.Optional[str]]] = None,
        tags: typing.Optional[typing.Dict[str, str]] = None,
        on_tick: typing.Optional[typing.Callable[[str, baml_py.baml_py.FunctionLog], None]] = None,
    ) -> "BamlSyncClient":
        options: BamlCallOptions = {}
        if tb is not None:
            options["tb"] = tb
        if client_registry is not None:
            options["client_registry"] = client_registry
        if collector is not None:
            options["collector"] = collector
        if env is not None:
            options["env"] = env
        if tags is not None:
            options["tags"] = tags
        if on_tick is not None:
            options["on_tick"] = on_tick
        return BamlSyncClient(self.__options.merge_options(options))

    @property
    def stream(self):
      return self.__stream_client

    @property
    def request(self):
      return self.__http_request

    @property
    def stream_request(self):
      return self.__http_stream_request

    @property
    def parse(self):
      return self.__llm_response_parser

    @property
    def parse_stream(self):
      return self.__llm_stream_parser
    
    def CalculateSimilarity(self, hypothesis1: types.Hypothesis,hypothesis2: types.Hypothesis,similarity_aspects: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> types.SimilarityScore:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.CalculateSimilarity(hypothesis1=hypothesis1,hypothesis2=hypothesis2,similarity_aspects=similarity_aspects,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="CalculateSimilarity", args={
                "hypothesis1": hypothesis1,"hypothesis2": hypothesis2,"similarity_aspects": similarity_aspects,
            })
            return typing.cast(types.SimilarityScore, result.cast_to(types, types, stream_types, False, __runtime__))
    def CompareHypotheses(self, hypothesis1: types.Hypothesis,hypothesis2: types.Hypothesis,comparison_criteria: typing.List[str],debate_context: typing.Optional[str] = None,
        baml_options: BamlCallOptions = {},
    ) -> types.ComparisonResult:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.CompareHypotheses(hypothesis1=hypothesis1,hypothesis2=hypothesis2,comparison_criteria=comparison_criteria,debate_context=debate_context,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="CompareHypotheses", args={
                "hypothesis1": hypothesis1,"hypothesis2": hypothesis2,"comparison_criteria": comparison_criteria,"debate_context": debate_context,
            })
            return typing.cast(types.ComparisonResult, result.cast_to(types, types, stream_types, False, __runtime__))
    def EnhanceHypothesis(self, original_hypothesis: types.Hypothesis,enhancement_strategy: str,feedback: typing.Optional[typing.List[str]] = None,complementary_hypothesis: typing.Optional["types.Hypothesis"] = None,
        baml_options: BamlCallOptions = {},
    ) -> types.Hypothesis:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.EnhanceHypothesis(original_hypothesis=original_hypothesis,enhancement_strategy=enhancement_strategy,feedback=feedback,complementary_hypothesis=complementary_hypothesis,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="EnhanceHypothesis", args={
                "original_hypothesis": original_hypothesis,"enhancement_strategy": enhancement_strategy,"feedback": feedback,"complementary_hypothesis": complementary_hypothesis,
            })
            return typing.cast(types.Hypothesis, result.cast_to(types, types, stream_types, False, __runtime__))
    def EvaluateHypothesis(self, hypothesis: types.Hypothesis,review_type: types.ReviewType,evaluation_criteria: typing.List[str],context: typing.Optional[typing.Dict[str, str]] = None,
        baml_options: BamlCallOptions = {},
    ) -> types.Review:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.EvaluateHypothesis(hypothesis=hypothesis,review_type=review_type,evaluation_criteria=evaluation_criteria,context=context,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="EvaluateHypothesis", args={
                "hypothesis": hypothesis,"review_type": review_type,"evaluation_criteria": evaluation_criteria,"context": context,
            })
            return typing.cast(types.Review, result.cast_to(types, types, stream_types, False, __runtime__))
    def ExtractResearchPatterns(self, hypotheses: typing.List["types.Hypothesis"],reviews: typing.List["types.Review"],focus: str,
        baml_options: BamlCallOptions = {},
    ) -> types.ResearchPatterns:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.ExtractResearchPatterns(hypotheses=hypotheses,reviews=reviews,focus=focus,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="ExtractResearchPatterns", args={
                "hypotheses": hypotheses,"reviews": reviews,"focus": focus,
            })
            return typing.cast(types.ResearchPatterns, result.cast_to(types, types, stream_types, False, __runtime__))
    def GenerateHypothesis(self, goal: str,constraints: typing.List[str],existing_hypotheses: typing.List["types.Hypothesis"],focus_area: typing.Optional[str],generation_method: str,
        baml_options: BamlCallOptions = {},
    ) -> types.Hypothesis:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.GenerateHypothesis(goal=goal,constraints=constraints,existing_hypotheses=existing_hypotheses,focus_area=focus_area,generation_method=generation_method,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="GenerateHypothesis", args={
                "goal": goal,"constraints": constraints,"existing_hypotheses": existing_hypotheses,"focus_area": focus_area,"generation_method": generation_method,
            })
            return typing.cast(types.Hypothesis, result.cast_to(types, types, stream_types, False, __runtime__))
    def ParseResearchGoal(self, natural_language_goal: str,domain_context: typing.Optional[str] = None,
        baml_options: BamlCallOptions = {},
    ) -> types.ParsedResearchGoal:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.ParseResearchGoal(natural_language_goal=natural_language_goal,domain_context=domain_context,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="ParseResearchGoal", args={
                "natural_language_goal": natural_language_goal,"domain_context": domain_context,
            })
            return typing.cast(types.ParsedResearchGoal, result.cast_to(types, types, stream_types, False, __runtime__))
    def PerformSafetyCheck(self, target_type: str,target_content: str,trust_level: str,safety_criteria: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> types.SafetyCheck:
        # Check if on_tick is provided
        if 'on_tick' in baml_options:
            stream = self.stream.PerformSafetyCheck(target_type=target_type,target_content=target_content,trust_level=trust_level,safety_criteria=safety_criteria,
                baml_options=baml_options)
            return stream.get_final_response()
        else:
            # Original non-streaming code
            result = self.__options.merge_options(baml_options).call_function_sync(function_name="PerformSafetyCheck", args={
                "target_type": target_type,"target_content": target_content,"trust_level": trust_level,"safety_criteria": safety_criteria,
            })
            return typing.cast(types.SafetyCheck, result.cast_to(types, types, stream_types, False, __runtime__))
    


class BamlStreamClient:
    __options: DoNotUseDirectlyCallManager

    def __init__(self, options: DoNotUseDirectlyCallManager):
        self.__options = options

    def CalculateSimilarity(self, hypothesis1: types.Hypothesis,hypothesis2: types.Hypothesis,similarity_aspects: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.SimilarityScore, types.SimilarityScore]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="CalculateSimilarity", args={
            "hypothesis1": hypothesis1,"hypothesis2": hypothesis2,"similarity_aspects": similarity_aspects,
        })
        return baml_py.BamlSyncStream[stream_types.SimilarityScore, types.SimilarityScore](
          result,
          lambda x: typing.cast(stream_types.SimilarityScore, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.SimilarityScore, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def CompareHypotheses(self, hypothesis1: types.Hypothesis,hypothesis2: types.Hypothesis,comparison_criteria: typing.List[str],debate_context: typing.Optional[str] = None,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.ComparisonResult, types.ComparisonResult]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="CompareHypotheses", args={
            "hypothesis1": hypothesis1,"hypothesis2": hypothesis2,"comparison_criteria": comparison_criteria,"debate_context": debate_context,
        })
        return baml_py.BamlSyncStream[stream_types.ComparisonResult, types.ComparisonResult](
          result,
          lambda x: typing.cast(stream_types.ComparisonResult, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.ComparisonResult, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def EnhanceHypothesis(self, original_hypothesis: types.Hypothesis,enhancement_strategy: str,feedback: typing.Optional[typing.List[str]] = None,complementary_hypothesis: typing.Optional["types.Hypothesis"] = None,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.Hypothesis, types.Hypothesis]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="EnhanceHypothesis", args={
            "original_hypothesis": original_hypothesis,"enhancement_strategy": enhancement_strategy,"feedback": feedback,"complementary_hypothesis": complementary_hypothesis,
        })
        return baml_py.BamlSyncStream[stream_types.Hypothesis, types.Hypothesis](
          result,
          lambda x: typing.cast(stream_types.Hypothesis, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.Hypothesis, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def EvaluateHypothesis(self, hypothesis: types.Hypothesis,review_type: types.ReviewType,evaluation_criteria: typing.List[str],context: typing.Optional[typing.Dict[str, str]] = None,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.Review, types.Review]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="EvaluateHypothesis", args={
            "hypothesis": hypothesis,"review_type": review_type,"evaluation_criteria": evaluation_criteria,"context": context,
        })
        return baml_py.BamlSyncStream[stream_types.Review, types.Review](
          result,
          lambda x: typing.cast(stream_types.Review, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.Review, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def ExtractResearchPatterns(self, hypotheses: typing.List["types.Hypothesis"],reviews: typing.List["types.Review"],focus: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.ResearchPatterns, types.ResearchPatterns]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="ExtractResearchPatterns", args={
            "hypotheses": hypotheses,"reviews": reviews,"focus": focus,
        })
        return baml_py.BamlSyncStream[stream_types.ResearchPatterns, types.ResearchPatterns](
          result,
          lambda x: typing.cast(stream_types.ResearchPatterns, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.ResearchPatterns, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def GenerateHypothesis(self, goal: str,constraints: typing.List[str],existing_hypotheses: typing.List["types.Hypothesis"],focus_area: typing.Optional[str],generation_method: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.Hypothesis, types.Hypothesis]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="GenerateHypothesis", args={
            "goal": goal,"constraints": constraints,"existing_hypotheses": existing_hypotheses,"focus_area": focus_area,"generation_method": generation_method,
        })
        return baml_py.BamlSyncStream[stream_types.Hypothesis, types.Hypothesis](
          result,
          lambda x: typing.cast(stream_types.Hypothesis, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.Hypothesis, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def ParseResearchGoal(self, natural_language_goal: str,domain_context: typing.Optional[str] = None,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.ParsedResearchGoal, types.ParsedResearchGoal]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="ParseResearchGoal", args={
            "natural_language_goal": natural_language_goal,"domain_context": domain_context,
        })
        return baml_py.BamlSyncStream[stream_types.ParsedResearchGoal, types.ParsedResearchGoal](
          result,
          lambda x: typing.cast(stream_types.ParsedResearchGoal, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.ParsedResearchGoal, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    def PerformSafetyCheck(self, target_type: str,target_content: str,trust_level: str,safety_criteria: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.BamlSyncStream[stream_types.SafetyCheck, types.SafetyCheck]:
        ctx, result = self.__options.merge_options(baml_options).create_sync_stream(function_name="PerformSafetyCheck", args={
            "target_type": target_type,"target_content": target_content,"trust_level": trust_level,"safety_criteria": safety_criteria,
        })
        return baml_py.BamlSyncStream[stream_types.SafetyCheck, types.SafetyCheck](
          result,
          lambda x: typing.cast(stream_types.SafetyCheck, x.cast_to(types, types, stream_types, True, __runtime__)),
          lambda x: typing.cast(types.SafetyCheck, x.cast_to(types, types, stream_types, False, __runtime__)),
          ctx,
        )
    

class BamlHttpRequestClient:
    __options: DoNotUseDirectlyCallManager

    def __init__(self, options: DoNotUseDirectlyCallManager):
        self.__options = options

    def CalculateSimilarity(self, hypothesis1: types.Hypothesis,hypothesis2: types.Hypothesis,similarity_aspects: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="CalculateSimilarity", args={
            "hypothesis1": hypothesis1,"hypothesis2": hypothesis2,"similarity_aspects": similarity_aspects,
        }, mode="request")
        return result
    def CompareHypotheses(self, hypothesis1: types.Hypothesis,hypothesis2: types.Hypothesis,comparison_criteria: typing.List[str],debate_context: typing.Optional[str] = None,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="CompareHypotheses", args={
            "hypothesis1": hypothesis1,"hypothesis2": hypothesis2,"comparison_criteria": comparison_criteria,"debate_context": debate_context,
        }, mode="request")
        return result
    def EnhanceHypothesis(self, original_hypothesis: types.Hypothesis,enhancement_strategy: str,feedback: typing.Optional[typing.List[str]] = None,complementary_hypothesis: typing.Optional["types.Hypothesis"] = None,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="EnhanceHypothesis", args={
            "original_hypothesis": original_hypothesis,"enhancement_strategy": enhancement_strategy,"feedback": feedback,"complementary_hypothesis": complementary_hypothesis,
        }, mode="request")
        return result
    def EvaluateHypothesis(self, hypothesis: types.Hypothesis,review_type: types.ReviewType,evaluation_criteria: typing.List[str],context: typing.Optional[typing.Dict[str, str]] = None,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="EvaluateHypothesis", args={
            "hypothesis": hypothesis,"review_type": review_type,"evaluation_criteria": evaluation_criteria,"context": context,
        }, mode="request")
        return result
    def ExtractResearchPatterns(self, hypotheses: typing.List["types.Hypothesis"],reviews: typing.List["types.Review"],focus: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="ExtractResearchPatterns", args={
            "hypotheses": hypotheses,"reviews": reviews,"focus": focus,
        }, mode="request")
        return result
    def GenerateHypothesis(self, goal: str,constraints: typing.List[str],existing_hypotheses: typing.List["types.Hypothesis"],focus_area: typing.Optional[str],generation_method: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="GenerateHypothesis", args={
            "goal": goal,"constraints": constraints,"existing_hypotheses": existing_hypotheses,"focus_area": focus_area,"generation_method": generation_method,
        }, mode="request")
        return result
    def ParseResearchGoal(self, natural_language_goal: str,domain_context: typing.Optional[str] = None,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="ParseResearchGoal", args={
            "natural_language_goal": natural_language_goal,"domain_context": domain_context,
        }, mode="request")
        return result
    def PerformSafetyCheck(self, target_type: str,target_content: str,trust_level: str,safety_criteria: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="PerformSafetyCheck", args={
            "target_type": target_type,"target_content": target_content,"trust_level": trust_level,"safety_criteria": safety_criteria,
        }, mode="request")
        return result
    

class BamlHttpStreamRequestClient:
    __options: DoNotUseDirectlyCallManager

    def __init__(self, options: DoNotUseDirectlyCallManager):
        self.__options = options

    def CalculateSimilarity(self, hypothesis1: types.Hypothesis,hypothesis2: types.Hypothesis,similarity_aspects: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="CalculateSimilarity", args={
            "hypothesis1": hypothesis1,"hypothesis2": hypothesis2,"similarity_aspects": similarity_aspects,
        }, mode="stream")
        return result
    def CompareHypotheses(self, hypothesis1: types.Hypothesis,hypothesis2: types.Hypothesis,comparison_criteria: typing.List[str],debate_context: typing.Optional[str] = None,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="CompareHypotheses", args={
            "hypothesis1": hypothesis1,"hypothesis2": hypothesis2,"comparison_criteria": comparison_criteria,"debate_context": debate_context,
        }, mode="stream")
        return result
    def EnhanceHypothesis(self, original_hypothesis: types.Hypothesis,enhancement_strategy: str,feedback: typing.Optional[typing.List[str]] = None,complementary_hypothesis: typing.Optional["types.Hypothesis"] = None,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="EnhanceHypothesis", args={
            "original_hypothesis": original_hypothesis,"enhancement_strategy": enhancement_strategy,"feedback": feedback,"complementary_hypothesis": complementary_hypothesis,
        }, mode="stream")
        return result
    def EvaluateHypothesis(self, hypothesis: types.Hypothesis,review_type: types.ReviewType,evaluation_criteria: typing.List[str],context: typing.Optional[typing.Dict[str, str]] = None,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="EvaluateHypothesis", args={
            "hypothesis": hypothesis,"review_type": review_type,"evaluation_criteria": evaluation_criteria,"context": context,
        }, mode="stream")
        return result
    def ExtractResearchPatterns(self, hypotheses: typing.List["types.Hypothesis"],reviews: typing.List["types.Review"],focus: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="ExtractResearchPatterns", args={
            "hypotheses": hypotheses,"reviews": reviews,"focus": focus,
        }, mode="stream")
        return result
    def GenerateHypothesis(self, goal: str,constraints: typing.List[str],existing_hypotheses: typing.List["types.Hypothesis"],focus_area: typing.Optional[str],generation_method: str,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="GenerateHypothesis", args={
            "goal": goal,"constraints": constraints,"existing_hypotheses": existing_hypotheses,"focus_area": focus_area,"generation_method": generation_method,
        }, mode="stream")
        return result
    def ParseResearchGoal(self, natural_language_goal: str,domain_context: typing.Optional[str] = None,
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="ParseResearchGoal", args={
            "natural_language_goal": natural_language_goal,"domain_context": domain_context,
        }, mode="stream")
        return result
    def PerformSafetyCheck(self, target_type: str,target_content: str,trust_level: str,safety_criteria: typing.List[str],
        baml_options: BamlCallOptions = {},
    ) -> baml_py.baml_py.HTTPRequest:
        result = self.__options.merge_options(baml_options).create_http_request_sync(function_name="PerformSafetyCheck", args={
            "target_type": target_type,"target_content": target_content,"trust_level": trust_level,"safety_criteria": safety_criteria,
        }, mode="stream")
        return result
    

b = BamlSyncClient(DoNotUseDirectlyCallManager({}))